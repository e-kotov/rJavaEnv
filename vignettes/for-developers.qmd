---
title: "Using `rJavaEnv` in R Packages"
vignette: >
  %\VignetteIndexEntry{Using `rJavaEnv` in R Packages}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
execute:
  eval: false
format:
  html:
    toc: true
    toc-depth: 2
    code-overflow: wrap
---

If you are developing an R package that involves `Java` (either via `{rJava}` or through command-line `Java` tools), you often face the "Java Hell" problem: your users might not have Java installed, or they might have the wrong version, or `{rJava}` cannot find the `JAVA_HOME`.

`rJavaEnv` solves this by providing a unified, reliable way to help your users ensure a specific Java version is present and configured correctly.

# The Critical Decision: Does Your Package Use rJava?

Before using `rJavaEnv`, you must categorize your package into one of two scenarios. This distinction is critical because `{rJava}` introduces a "locking" constraint that fundamentally changes how you must manage Java.

**Scenario A: Command-Line Java Only** (No `{rJava}` dependency)
Your package calls Java executables via `system()`, `system2()`, or `processx`. You do **not** have `Imports: rJava` in your DESCRIPTION.

**Scenario B: rJava Dependency** (Most Common)
Your package has `Imports: rJava` or `Depends: rJava`, or executes code that uses `{rJava}` functions.

---

# Scenario A: Packages Using Command-Line Java (No rJava)

In this scenario, you have flexibility. The Java version is **not** locked by the R session. You can use different Java versions for different tasks or change them dynamically.

However, `rJavaEnv::java_ensure()` modifies the global `JAVA_HOME` and `PATH` environment variables for the current R session. If you change these variables inside your function, you might accidentally affect other parts of the user's workflow.

### Strategy: Scoped execution "Set, Run, Reset"

To use a specific Java version safely without polluting the user's global session, you should use a **scoped** approach.

#### Recommended Pattern: Use `on.exit()`

You can use `on.exit()` to ensure that environment variables are restored to their original state immediately after your function finishes (even if it errors).

```r
#' Run my Java tool safely
#' @export
run_my_java_tool <- function(input_file) {
  # 1. Capture the current "Safe State"
  old_java_home <- Sys.getenv("JAVA_HOME")
  old_path <- Sys.getenv("PATH")
  
  # 2. Schedule restoration immediately
  # This ensures env vars are reset when this function exits
  on.exit({
    Sys.setenv(JAVA_HOME = old_java_home)
    Sys.setenv(PATH = old_path)
  }, add = TRUE)
  
  # 3. Set the required Java environment for this function scope
  # This modifies the session, but only temporarily thanks to on.exit
  # Use .use_cache = TRUE for performance in repeated calls
  rJavaEnv::java_ensure(
    version = 21, 
    type = "min", 
    install = FALSE, 
    quiet = TRUE,
    .use_cache = TRUE 
  )
  
  # 4. Run your Java command
  # The environment is now set up correctly for this call
  system2("java", c("-jar", "my-tool.jar", "--input", input_file))
}
```

This pattern ensures that:
1.  Your tool always runs with the correct Java version (e.g., Java 21).
2.  The user's global environment remains clean.
3.  Other packages relying on different Java versions are not affected.

#### Alternative: Using `withr`

If you already use the `{withr}` package, you can achieve the same effect more concisely using `withr::defer()`:

```r
run_my_java_tool <- function() {
  # Automatically handle state restoration
  withr::local_envvar(c("JAVA_HOME" = Sys.getenv("JAVA_HOME")))
  # Note: restoring PATH is trickier with local_envvar as it merges, 
  # so manual on.exit or a custom helper is often safer for PATH.
  
  # ... rest of logic
}
```
*Note: Because `rJavaEnv` modifies PATH by prepending, a manual `on.exit` (as shown above) is generally more robust for full restoration.*

### Controlling Whether to Use System Java

By default, `accept_system_java = TRUE`. `rJavaEnv` will first check if a suitable Java version exists on the system. If found, it uses it without downloading anything. This is efficient and recommended.

If you strictly require an isolated, reproducible environment (ignoring the user's system Java), set `accept_system_java = FALSE` and `install = TRUE`.

---

# Scenario B: Packages Importing rJava

If your package calls `rJava` (or imports a package that does), you face a strict constraint:

> **The rJava Lock**: Once `{rJava}` is initialized (loaded), the Java version is **locked** for the entire R session. It cannot be changed without restarting R.

**Implications:**
- You **cannot** set Java in your package's `.onLoad` or inside your functions. By the time your package loads, `{rJava}` is likely already initializing, or will initialize the moment you call it.
- You **must** instruct users to set up Java **before** loading your package.

### Strategy: "Inform and Guide"

Your goal is to make the setup process as easy as possible for your users.

#### 1. Add rJavaEnv to Imports

Add `rJavaEnv` to your `DESCRIPTION`:
```dcf
Imports:
    rJava,
    rJavaEnv
```

#### 2. Document the Requirement

In your README or vignette, provide clear instructions.

> **Java Requirement**
> This package requires Java 21+. If you see errors, run:
> ```r
> library(rJavaEnv)
> java_ensure(version = 21, type = "min")
> # RESTART R session
> library(your_package)
> ```

#### 3. Optional: Provide a Setup Helper

To make it even easier, you can export a setup function that users can call *if* they run into issues. This function can leverage `java_ensure(install = TRUE)` to interactively guide them.

```r
#' Install and Configure Java
#' @export
setup_java <- function() {
  # Interactive check and install
  rJavaEnv::java_ensure(version = 21, type = "min", install = TRUE)
  
  message("Java setup complete. Please RESTART your R session for changes to take effect.")
}
```

#### 4. Optional: Diagnostic Message in .onLoad

You can check the environment in `.onLoad` and print a helpful message if Java is missing or incorrect, but **do not try to fix it there**.

```r
.onLoad <- function(libname, pkgname) {
  # Check only (do not change env)
  # Use quiet=TRUE to minimize noise
  has_java <- rJavaEnv::java_check_version_cmd(quiet = TRUE, .use_cache = TRUE)
  
  if (isFALSE(has_java)) {
    packageStartupMessage("Java not found! Run setup_java() and restart R.")
  }
}
```

---

# Performance & Caching

Regardless of the scenario, `rJavaEnv` performs checks to ensure Java is ready. To avoid performance penalties (approx. 30-200ms per check), `rJavaEnv` supports session-level caching.

### When to use `.use_cache = TRUE`

-   **Inside functions called repeatedly**: If you have a function calling `java_ensure` inside a loop, enable caching.
-   **In `.onLoad` checks**: To keep package startup fast.

```r
# Fast check using cache
rJavaEnv::java_check_version_cmd(quiet = TRUE, .use_cache = TRUE)
```

The first call takes time (to verify the system state), but subsequent calls in the same session return in <1ms.

---

# CI/CD (GitHub Actions)

Ensure Java is available in your CI workflows.

**Option A: Standard generic action (Recommended)**
```yaml
- uses: actions/setup-java@v4
  with:
    distribution: 'corretto'
    java-version: '21'
```

**Option B: Using rJavaEnv**
```yaml
- name: Install Java via rJavaEnv
  run: |
    install.packages("rJavaEnv")
    rJavaEnv::java_ensure(version = 21, type = "min")
  shell: Rscript {0}
```
